diff --git a/program-runtime/Cargo.toml b/program-runtime/Cargo.toml
index 91936e4d22..fe1b081cdf 100644
--- a/program-runtime/Cargo.toml
+++ b/program-runtime/Cargo.toml
@@ -27,4 +27,6 @@ thiserror = "1.0"
 enum-iterator = "0.8.1"
 
+test-fuzz = { path = "../../../test-fuzz" }
+
 [dev-dependencies]
 solana-logger = { path = "../logger", version = "=1.11.0" }
diff --git a/program-runtime/src/accounts_data_meter.rs b/program-runtime/src/accounts_data_meter.rs
index 244ce9b118..27cd88e8b2 100644
--- a/program-runtime/src/accounts_data_meter.rs
+++ b/program-runtime/src/accounts_data_meter.rs
@@ -11,5 +11,5 @@ pub const MAX_ACCOUNTS_DATA_LEN: u64 = 128_000_000_000;
 
 /// Meter and track the amount of available accounts data space
-#[derive(Debug, Default, Clone, Copy, Eq, PartialEq)]
+#[derive(Debug, Default, Clone, Copy, Eq, PartialEq, serde::Deserialize, serde::Serialize)]
 pub struct AccountsDataMeter {
     /// The maximum amount of accounts data space that can be used (in bytes)
diff --git a/program-runtime/src/compute_budget.rs b/program-runtime/src/compute_budget.rs
index 0adbc64db7..5174f357cb 100644
--- a/program-runtime/src/compute_budget.rs
+++ b/program-runtime/src/compute_budget.rs
@@ -23,5 +23,5 @@ impl ::solana_frozen_abi::abi_example::AbiExample for ComputeBudget {
 }
 
-#[derive(Clone, Copy, Debug, PartialEq, Eq)]
+#[derive(Clone, Copy, Debug, PartialEq, Eq, serde::Deserialize, serde::Serialize)]
 pub struct ComputeBudget {
     /// Number of compute units that a transaction or individual instruction is
diff --git a/program-runtime/src/invoke_context.rs b/program-runtime/src/invoke_context.rs
index 584d2ee652..77b84a32af 100644
--- a/program-runtime/src/invoke_context.rs
+++ b/program-runtime/src/invoke_context.rs
@@ -139,4 +139,5 @@ impl TransactionExecutor {
 
 /// Compute meter
+#[derive(Clone, serde::Deserialize, serde::Serialize)]
 pub struct ComputeMeter {
     remaining: u64,
@@ -188,4 +189,5 @@ impl fmt::Display for AllocErr {
 )]
 #[allow(deprecated)]
+#[derive(Clone, serde::Deserialize, serde::Serialize)]
 pub struct StackFrame<'a> {
     pub number_of_program_accounts: usize,
@@ -215,12 +217,55 @@ impl<'a> StackFrame<'a> {
 }
 
+struct DummyAllocator;
+
+impl Alloc for DummyAllocator {
+    fn alloc(&mut self, _layout: Layout) -> Result<u64, AllocErr> {
+        std::process::exit(0);
+    }
+    fn dealloc(&mut self, _addr: u64, _layout: Layout) {
+        std::process::exit(0);
+    }
+}
+
+fn dummy_allocator() -> Rc<RefCell<dyn Alloc>> {
+    Rc::new(RefCell::new(DummyAllocator))
+}
+
+#[derive(Clone, serde::Deserialize, serde::Serialize)]
 struct SyscallContext {
     check_aligned: bool,
     check_size: bool,
     orig_account_lengths: Vec<usize>,
+    #[serde(skip, default = "dummy_allocator")]
     allocator: Rc<RefCell<dyn Alloc>>,
 }
 
+pub fn serialize_ref_mut<S, T>(x: &&mut T, serializer: S) -> Result<S::Ok, S::Error>
+where
+    S: serde::Serializer,
+    T: serde::Serialize,
+{
+    <T as serde::Serialize>::serialize(*x, serializer)
+}
+
+pub fn deserialize_ref_mut<'de, D, T>(deserializer: D) -> Result<&'static mut T, D::Error>
+where
+    D: serde::Deserializer<'de>,
+    T: serde::de::DeserializeOwned + std::fmt::Debug,
+{
+    let x = <T as serde::de::Deserialize>::deserialize(deserializer)?;
+    Ok(Box::leak(Box::new(x)))
+}
+
+fn default_builtin_programs() -> &'static [BuiltinProgram] {
+    Box::leak(Box::new([]))
+}
+
+#[derive(serde::Deserialize, serde::Serialize)]
 pub struct InvokeContext<'a> {
+    #[serde(
+        serialize_with = "serialize_ref_mut",
+        deserialize_with = "deserialize_ref_mut"
+    )]
     pub transaction_context: &'a mut TransactionContext,
     #[allow(deprecated)]
@@ -228,4 +273,5 @@ pub struct InvokeContext<'a> {
     rent: Rent,
     pre_accounts: Vec<PreAccount>,
+    #[serde(skip, default = "default_builtin_programs")]
     builtin_programs: &'a [BuiltinProgram],
     pub sysvar_cache: Cow<'a, SysvarCache>,
@@ -235,4 +281,5 @@ pub struct InvokeContext<'a> {
     compute_meter: Rc<RefCell<ComputeMeter>>,
     accounts_data_meter: AccountsDataMeter,
+    #[serde(skip)]
     executors: Rc<RefCell<Executors>>,
     pub feature_set: Arc<FeatureSet>,
@@ -243,4 +290,22 @@ pub struct InvokeContext<'a> {
 }
 
+impl<'a> Clone for InvokeContext<'a> {
+    fn clone(&self) -> Self {
+        Self {
+            transaction_context: Box::leak(Box::new(self.transaction_context.clone())),
+            invoke_stack: self.invoke_stack.clone(),
+            pre_accounts: self.pre_accounts.clone(),
+            sysvar_cache: self.sysvar_cache.clone(),
+            log_collector: self.log_collector.clone(),
+            compute_meter: self.compute_meter.clone(),
+            executors: self.executors.clone(),
+            feature_set: self.feature_set.clone(),
+            timings: self.timings.clone(),
+            syscall_context: self.syscall_context.clone(),
+            ..*self
+        }
+    }
+}
+
 impl<'a> InvokeContext<'a> {
     #[allow(clippy::too_many_arguments)]
diff --git a/program-runtime/src/log_collector.rs b/program-runtime/src/log_collector.rs
index 57ac1cede6..aacc5cf434 100644
--- a/program-runtime/src/log_collector.rs
+++ b/program-runtime/src/log_collector.rs
@@ -4,4 +4,5 @@ use std::{cell::RefCell, rc::Rc};
 const LOG_MESSAGES_BYTES_LIMIT: usize = 10 * 1000;
 
+#[derive(Clone, serde::Deserialize, serde::Serialize)]
 pub struct LogCollector {
     messages: Vec<String>,
diff --git a/program-runtime/src/pre_account.rs b/program-runtime/src/pre_account.rs
index 842d5ae670..dc0aff5a26 100644
--- a/program-runtime/src/pre_account.rs
+++ b/program-runtime/src/pre_account.rs
@@ -14,5 +14,5 @@ use {
 // The relevant state of an account before an Instruction executes, used
 // to verify account integrity after the Instruction completes
-#[derive(Clone, Debug, Default)]
+#[derive(Clone, Debug, Default, serde::Deserialize, serde::Serialize)]
 pub struct PreAccount {
     key: Pubkey,
diff --git a/program-runtime/src/sysvar_cache.rs b/program-runtime/src/sysvar_cache.rs
index 9469b94ab2..62bad26076 100644
--- a/program-runtime/src/sysvar_cache.rs
+++ b/program-runtime/src/sysvar_cache.rs
@@ -24,5 +24,5 @@ impl ::solana_frozen_abi::abi_example::AbiExample for SysvarCache {
 }
 
-#[derive(Default, Clone, Debug)]
+#[derive(Default, Clone, Debug, serde::Deserialize, serde::Serialize)]
 pub struct SysvarCache {
     clock: Option<Arc<Clock>>,
diff --git a/program-runtime/src/timings.rs b/program-runtime/src/timings.rs
index f342b9d5ca..83a700ad77 100644
--- a/program-runtime/src/timings.rs
+++ b/program-runtime/src/timings.rs
@@ -9,5 +9,5 @@ use {
 };
 
-#[derive(Default, Debug, PartialEq, Eq)]
+#[derive(Default, Debug, PartialEq, Eq, Clone, serde::Deserialize, serde::Serialize)]
 pub struct ProgramTiming {
     pub accumulated_us: u64,
@@ -154,5 +154,5 @@ impl ExecuteAccessoryTimings {
 }
 
-#[derive(Default, Debug, PartialEq, Eq)]
+#[derive(Default, Debug, PartialEq, Eq, Clone, serde::Deserialize, serde::Serialize)]
 pub struct ExecuteDetailsTimings {
     pub serialize_us: u64,
diff --git a/programs/bpf_loader/Cargo.toml b/programs/bpf_loader/Cargo.toml
index f517009d6f..9ddafeb401 100644
--- a/programs/bpf_loader/Cargo.toml
+++ b/programs/bpf_loader/Cargo.toml
@@ -23,4 +23,7 @@ solana_rbpf = "=0.2.29"
 thiserror = "1.0"
 
+serde = "1.0"
+test-fuzz = { path = "../../../../test-fuzz" }
+
 [dev-dependencies]
 rand = "0.7.3"
diff --git a/programs/bpf_loader/src/lib.rs b/programs/bpf_loader/src/lib.rs
index c2f02b3157..77f9196511 100644
--- a/programs/bpf_loader/src/lib.rs
+++ b/programs/bpf_loader/src/lib.rs
@@ -276,7 +276,8 @@ pub fn create_vm<'a, 'b>(
 }
 
-pub fn process_instruction(
+#[test_fuzz::test_fuzz]
+pub fn process_instruction<'a>(
     first_instruction_account: usize,
-    invoke_context: &mut InvokeContext,
+    invoke_context: &mut InvokeContext<'a>,
 ) -> Result<(), InstructionError> {
     process_instruction_common(first_instruction_account, invoke_context, false)
diff --git a/sdk/Cargo.toml b/sdk/Cargo.toml
index 751c30c66d..55e2578b08 100644
--- a/sdk/Cargo.toml
+++ b/sdk/Cargo.toml
@@ -66,5 +66,5 @@ rand = { version = "0.7.0", optional = true }
 rand_chacha = { version = "0.2.2", optional = true }
 rustversion = "1.0.6"
-serde = "1.0.137"
+serde = { version = "1.0.137", features = ["rc"] }
 serde_bytes = "0.11"
 serde_derive = "1.0.103"
@@ -81,4 +81,6 @@ uriparse = "0.6.4"
 wasm-bindgen = "0.2"
 
+test-fuzz = { path = "../../../test-fuzz" }
+
 [target.'cfg(target_arch = "wasm32")'.dependencies]
 js-sys = "0.3.57"
diff --git a/sdk/src/account.rs b/sdk/src/account.rs
index 9ba920cb4e..cfb4e82647 100644
--- a/sdk/src/account.rs
+++ b/sdk/src/account.rs
@@ -95,5 +95,5 @@ impl Serialize for AccountSharedData {
 /// This will be the in-memory representation of the 'Account' struct data.
 /// The existing 'Account' structure cannot easily change due to downstream projects.
-#[derive(PartialEq, Eq, Clone, Default, AbiExample)]
+#[derive(PartialEq, Eq, Clone, Default, AbiExample, serde::Deserialize)]
 pub struct AccountSharedData {
     /// lamports in the account
diff --git a/sdk/src/feature_set.rs b/sdk/src/feature_set.rs
index 244d2b70f3..69d8fb1cfd 100644
--- a/sdk/src/feature_set.rs
+++ b/sdk/src/feature_set.rs
@@ -552,5 +552,5 @@ lazy_static! {
 
 /// `FeatureSet` holds the set of currently active/inactive runtime features
-#[derive(AbiExample, Debug, Clone)]
+#[derive(AbiExample, Debug, Clone, serde::Deserialize, serde::Serialize)]
 pub struct FeatureSet {
     pub active: HashMap<Pubkey, Slot>,
diff --git a/sdk/src/keyed_account.rs b/sdk/src/keyed_account.rs
index f21876ddaa..b4a0628ef4 100644
--- a/sdk/src/keyed_account.rs
+++ b/sdk/src/keyed_account.rs
@@ -17,10 +17,39 @@ use {
 };
 
+fn serialize_account<'a, S>(
+    account: &&'a RefCell<AccountSharedData>,
+    serializer: S,
+) -> Result<S::Ok, S::Error>
+where
+    S: serde::Serializer,
+{
+    <RefCell<AccountSharedData> as serde::Serialize>::serialize(&*account, serializer)
+}
+
+fn deserialize_account<'de, D>(
+    deserializer: D,
+) -> Result<&'static RefCell<AccountSharedData>, D::Error>
+where
+    D: serde::Deserializer<'de>,
+{
+    let account =
+        <RefCell<AccountSharedData> as serde::de::Deserialize>::deserialize(deserializer)?;
+    Ok(Box::leak(Box::new(Rc::new(account))))
+}
+
 #[repr(C)]
-#[derive(Debug, Clone)]
+#[derive(Debug, Clone, serde::Deserialize, serde::Serialize)]
 pub struct KeyedAccount<'a> {
     is_signer: bool, // Transaction was signed by this account's key
     is_writable: bool,
+    #[serde(
+        serialize_with = "test_fuzz::serialize_ref",
+        deserialize_with = "test_fuzz::deserialize_ref"
+    )]
     key: &'a Pubkey,
+    #[serde(
+        serialize_with = "serialize_account",
+        deserialize_with = "deserialize_account"
+    )]
     pub account: &'a RefCell<AccountSharedData>,
 }
diff --git a/sdk/src/transaction_context.rs b/sdk/src/transaction_context.rs
index d238cf5f2d..e28df3cdaa 100644
--- a/sdk/src/transaction_context.rs
+++ b/sdk/src/transaction_context.rs
@@ -20,5 +20,5 @@ pub type TransactionAccount = (Pubkey, AccountSharedData);
 ///
 /// It also contains indices to other structures for faster lookup.
-#[derive(Clone, Debug)]
+#[derive(Clone, Debug, serde::Deserialize, serde::Serialize)]
 pub struct InstructionAccount {
     /// Points to the account and its key in the `TransactionContext`
@@ -38,10 +38,57 @@ pub struct InstructionAccount {
 }
 
+fn serialize_account_keys<'a, S>(
+    account_keys: &Pin<Box<[Pubkey]>>,
+    serializer: S,
+) -> Result<S::Ok, S::Error>
+where
+    S: serde::Serializer,
+{
+    <[Pubkey] as serde::Serialize>::serialize(&**account_keys, serializer)
+}
+
+fn deserialize_account_keys<'de, D>(deserializer: D) -> Result<Pin<Box<[Pubkey]>>, D::Error>
+where
+    D: serde::Deserializer<'de>,
+{
+    let account_keys = <Vec<Pubkey> as serde::de::Deserialize>::deserialize(deserializer)?;
+    Ok(Pin::new(account_keys.into_boxed_slice()))
+}
+
+fn serialize_accounts<'a, S>(
+    accounts: &Pin<Box<[RefCell<AccountSharedData>]>>,
+    serializer: S,
+) -> Result<S::Ok, S::Error>
+where
+    S: serde::Serializer,
+{
+    <[RefCell<AccountSharedData>] as serde::Serialize>::serialize(&**accounts, serializer)
+}
+
+fn deserialize_accounts<'de, D>(
+    deserializer: D,
+) -> Result<Pin<Box<[RefCell<AccountSharedData>]>>, D::Error>
+where
+    D: serde::Deserializer<'de>,
+{
+    let accounts =
+        <Vec<RefCell<AccountSharedData>> as serde::de::Deserialize>::deserialize(deserializer)?;
+    Ok(Pin::new(accounts.into_boxed_slice()))
+}
+
 /// Loaded transaction shared between runtime and programs.
 ///
 /// This context is valid for the entire duration of a transaction being processed.
-#[derive(Debug)]
+#[derive(Debug, Clone, serde::Deserialize, serde::Serialize)]
 pub struct TransactionContext {
+    #[serde(
+        serialize_with = "serialize_account_keys",
+        deserialize_with = "deserialize_account_keys"
+    )]
     account_keys: Pin<Box<[Pubkey]>>,
+    #[serde(
+        serialize_with = "serialize_accounts",
+        deserialize_with = "deserialize_accounts"
+    )]
     accounts: Pin<Box<[RefCell<AccountSharedData>]>>,
     instruction_context_capacity: usize,
@@ -266,5 +313,5 @@ pub type InstructionTrace = Vec<Vec<InstructionContext>>;
 ///
 /// This context is valid for the entire duration of a (possibly cross program) instruction being processed.
-#[derive(Debug, Clone)]
+#[derive(Debug, Clone, serde::Deserialize, serde::Serialize)]
 pub struct InstructionContext {
     nesting_level: usize,
